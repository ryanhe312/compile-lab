<h3 align='center'> Project 1 词法分析  </h3>
<p align='center'> 16307110216 何瑞安  </p>
<p align='center'> 16307110042 王子仪  </p>
#### 1 flex的用法

flex是一个快速的词法分析器生成器，我们只需要输入规则，flex就能产生词法分析的C程序。



首先，flex规则文件的结构很简单，由标识符，规则和用户代码构成。标识符是正则表达式及其组合，规则是匹配正则表达式或者标识符之后进行的动作，最后可以添加用户代码直接调用flex的接口。

标识符区还可添加头文件和生成选项，比如`%option noyywrap`是不允许更换输入缓冲区。本实验中该代码是`lexer.l`。

```c
标识符
%%
标识符或正则表达式 {执行规则}
%%
代码
```



其次，flex规则文件经过flex处理之后会生成一个C语言文件，也就是分析器代码。这个C语言文件中有许多可以直接调用的接口，我们可以从接口获取词法分析的结果，本实验使用的接口如下所示。本实验中会生成`lexer.c`。

* `yyset_in`： 更改输入源
* `yylex`： 进行一次解析
* `yyleng`： 匹配长度
* `yytext`： 匹配文字



最后，我们将主程序和flex生成的分析器代码一起编译就可以生成词法分析器，具体的bash代码如下所示。

```bash
flex -o lexer.c lexer.l
g++ lexer.c main.c -o lexer
```

#### 2 正则表达式识别

首先我们在`lexer.h`规定每个词的类型代码，然后让分析器和主程序根据类型代码进行交互。我们本次实验使用的PCAT语言具有以下几种标识符，注意其中特殊字符需要进行`\`转义。

* 对于关键字（Keyword），分隔符（Delimiter）和运算符（Operator），我们直接在规则中设定并匹配即可，返回值是其类型编号。
* 对于字符（Letter），我们使用`[A-Za-z]`进行匹配。
* 对于数字（Digit），我们使用`[0-9]`进行匹配。
* 对于整数（Integer），我们使用`{DIGIT}+`进行匹配。
* 对于浮点数（Real），我们使用`{DIGIT}+"."{DIGIT}*`进行匹配。

* 对于标识符（Identifier），我们使用`{LETTER}({DIGIT}|{LETTER})*`进行匹配。

* 对于字符串（String），我们使用`\"[^\"\n\t]*\"`进行匹配。



其他我们在规则中还需要处理以下特殊情况：

* 文本结束符`<<EOF>>`：停止解析。
* 换行符`\n`：更新行数和列数。
* 空白符`[ \t]+`：什么也不做。
* 其他非法字符：返回ILLEGAL CHAR错误。



最后我们还需要处理注释，PCAT语言的注释由`(*`和`*)`括起来，可以跨越多行，我们需要一个区别于普通状态（flex中这种状态叫`INITIAL`或者用`0`表示）的有限自动机状态来表示注释状态下的匹配，幸运的是flex提供了这样的功能。

1. `%x COMMENT`：定义标识符，作为注释状态。
2. `"(*" {BEGIN(COMMENT);}  `：能够在遇到`(*`的时候进入注释状态。
3. `<COMMENT>"*)"  {BEGIN(INITIAL)};`：能够在遇到`*)`的时候退出注释状态。
4. `<COMMENT>\n   {row++,col=1;}`：能够在遇到换行符的时候更新行数和列数。
5. `<COMMENT>. {}`：在匹配到其他字符时什么也不做。



#### 3 行列号与报错实现

对于行列号，我们分别定义了`row`和`col`两个变量进行记录，当遇到换行符的时候我们将`row`增加，并将`col`重置为1。这里我们使用了flex的一个特性，定义宏`YY_USER_ACTION`可以在解析之后，规则之前进行一次操作，我们在此时加上匹配到的字符的长度`yyleng`即可。



对于报错，我们将错误作为一种TOKEN并返回ERROR类型，并在`lexer.h`规定了错误的类型，我们定义了`error`变量来指示报错类型，`YY_ERROR`宏来方便进行报错。

* ILLEGAL_CHAR：非法字符，我们在规则最后通过通配符`.`进行查错。
* INVALID_INTEGER：整数大小超过2^31-1，我们通过判断数字长度和与最大值比较进行查错。
* ILLEGAL_REAL：浮点数超过255字符，我们通过判断数字长度进行查错。
* ILLEGAL_ID：标识符超过255字符，我们通过判断标识符长度进行查错。
* ILLEGAL_STRING：字符串超过255字符，我们通过判断字符串长度进行查错。
* INVALID_STRING：字符串中有`\t`，我们通过`\"[^\"\n]*\"`匹配进行查错。
* UNTERMINATED_STRING：字符串跨行或者没有封闭，我们通过`\"[^\"\n]*\n`和`\"[^\"\n]*`匹配进行查错。
*  UNTERMINATED_COMMENT：注释没有封闭，我们在注释状态下通过`<COMMENT><<EOF>>`匹配进行查错。

#### 4 项目分工与贡献

何瑞安 60%：负责代码书写，共同讨论。

王子仪 40%：负责报告书写，共同讨论。